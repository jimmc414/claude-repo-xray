# {PROJECT_NAME}: AI Coding Assistant Onboarding

> **Purpose:** Enable a fresh Claude instance to work effectively in this codebase
> **Prepared by:** repo_xray agent
> **Codebase:** {FILE_COUNT} files, ~{TOTAL_TOKENS} tokens
> **This document:** ~{DOC_TOKENS} tokens
> **Generated:** {TIMESTAMP}
> **From commit:** {GIT_COMMIT_HASH}

---

## TL;DR (5 Bullets Max)

{TLDR}

<!--
AGENT INSTRUCTIONS:
If a developer has 60 seconds, what do they NEED to know?
- What is this? (1 sentence)
- Where does core logic live? (1-2 files)
- What's the critical path? (entry → processing → output)
- What to avoid? (biggest hazard)
- How to run it? (1 command)

Example:
- **KOSMOS** = autonomous AI research platform using Claude
- **Core logic** lives in `agents/research_director.py` (use skeleton only — 21K tokens)
- **Flow:** CLI → ResearchDirector → specialized agents → results
- **Avoid:** `kosmos-claude-scientific-skills/` (external, not core)
- **Run:** `kosmos run "your research question" --domain physics`
-->

---

## Quick Orientation

{QUICK_ORIENTATION}

<!--
AGENT INSTRUCTIONS:
Write 2-4 sentences answering:
- What is this codebase? (purpose)
- What does it do? (functionality)
- What's the tech stack? (frameworks, key dependencies)
- What's the architecture style? (monolith, microservices, layered, etc.)

This should be YOUR synthesis, not copied from X-Ray.
Example: "OrderSystem is a FastAPI e-commerce backend processing orders for 7 payment
providers. It uses a clean 3-layer architecture (API → Services → Data) with SQLAlchemy
ORM and Redis caching. The core complexity lives in the payment orchestration layer."
-->

---

## Architecture

{MERMAID_DIAGRAM}

<!--
AGENT INSTRUCTIONS:
Include the Mermaid diagram from X-Ray verbatim — it's already good.
Add a brief annotation if helpful.
-->

### Layer Summary

| Layer | Purpose | Key Modules |
|-------|---------|-------------|
| **Orchestration** | {ORCH_PURPOSE} | {ORCH_MODULES} |
| **Core** | {CORE_PURPOSE} | {CORE_MODULES} |
| **Foundation** | {FOUND_PURPOSE} | {FOUND_MODULES} |

<!--
AGENT INSTRUCTIONS:
Fill in based on X-Ray layers + your investigation.
Example:
| Orchestration | API routes, CLI | api/, cli.py |
| Core | Business logic | services/, core/ |
| Foundation | Utilities, base classes | lib/, models/ |
-->

---

## Critical Components

<!--
AGENT INSTRUCTIONS:
NOT a dump of all pillars. Include only components you VERIFIED as important.
For each, provide:
- File path and why it matters
- Key classes/functions (skeleton or summary)
- Your assessment from investigation
- Mark with [VERIFIED], [INFERRED], or [X-RAY SIGNAL]
-->

### {COMPONENT_1_NAME}

**File:** `{COMPONENT_1_PATH}` | **Why it matters:** {COMPONENT_1_WHY}

```python
{COMPONENT_1_SKELETON}
```

**What to know:** {COMPONENT_1_INSIGHTS}

<!--
Example:
### Order Engine
**File:** `core/engine.py` | **Why it matters:** [VERIFIED] Central orchestrator for all order processing

```python
class OrderEngine:
    def __init__(self, payment_provider: PaymentProvider, inventory: InventoryService): ...
    def process_order(self, order: Order) -> OrderResult: ...  # CC=25, main entry point
    def validate(self, order: Order) -> ValidationResult: ...
    def execute_payment(self, order: Order) -> PaymentResult: ...
```

**What to know:** [VERIFIED] Uses strategy pattern for payment providers. The `process_order` method is the
critical path — handles validation, payment, inventory reservation, and fulfillment in sequence.
[VERIFIED] Retry logic with exponential backoff for payment failures (2s, 4s, 8s).
-->

### {COMPONENT_2_NAME}

**File:** `{COMPONENT_2_PATH}` | **Why it matters:** {COMPONENT_2_WHY}

{COMPONENT_2_CONTENT}

<!-- Repeat for 3-5 critical components -->

---

## Data Flow

<!--
AGENT INSTRUCTIONS:
Trace a typical request/operation through the system.
Show the sequence, not just a list.
Include file:line references where possible.
-->

```
{DATA_FLOW_DIAGRAM}
```

<!--
Example:
```
API Request (POST /orders)
    │
    ▼
OrderRouter.create_order()          ─── api/routes/orders.py:45
    │
    ▼
OrderService.create()               ─── services/order_service.py:23
    │
    ├──▶ Validator.validate()       ─── core/validators.py:67
    │
    ├──▶ InventoryService.reserve() ─── services/inventory.py:89
    │         │
    │         └──▶ [DB: UPDATE inventory]
    │
    ├──▶ PaymentProvider.charge()   ─── providers/{stripe,paypal}/
    │         │
    │         └──▶ [API: External payment gateway]
    │
    └──▶ OrderRepository.save()     ─── repositories/order.py:34
              │
              └──▶ [DB: INSERT orders]
    │
    ▼
Response (OrderCreated)
```
-->

---

## Complexity Guide

<!--
AGENT INSTRUCTIONS:
Only include complexity hotspots you INVESTIGATED.
Provide your verdict: essential vs accidental complexity.
Generate logic map for essential complexity.
Mark confidence level.
-->

### {COMPLEX_FUNCTION_1} (CC={CC_1})

**Location:** `{FILE_1}:{LINE_1}`
**Verdict:** {VERDICT_1}

{COMPLEXITY_CONTENT_1}

<!--
Example for ESSENTIAL complexity:

### process_order() (CC=25)
**Location:** `core/engine.py:45`
**Verdict:** [VERIFIED] Essential — business logic requires this complexity

**Logic Map:**
```
process_order(order):
  -> validate(order)
  -> valid?
     {status = "processing"}
     * for item in order.items:
       -> check_inventory(item)
       -> available?
          [DB: reserve(item)]
       -> not available?
          -> rollback_reservations()
          -> Return(OutOfStock)
     -> select_payment_provider(order.payment_method)
     -> charge(order.total)
     -> success?
        [DB: save(order)]
        [Email: confirmation]
        -> Return(Success)
     -> failure?
        -> rollback_reservations()
        -> Return(PaymentFailed)
```

**Why it's complex:** Handles 7 payment providers, inventory reservation with rollback,
and transactional consistency. The complexity reflects real business requirements.

---

Example for ACCIDENTAL complexity:

### validate_input() (CC=18)
**Location:** `api/handlers.py:102`
**Verdict:** [VERIFIED] Accidental — candidate for refactoring

**Issue:** Giant switch statement mixing schema validation with business rules.

**Recommendation:** Split into:
- `validate_schema()` — Data type and format checks
- `validate_business_rules()` — Domain logic validation

Not on critical path — safe to refactor incrementally.
-->

---

## Side Effects & I/O

<!--
AGENT INSTRUCTIONS:
Include VERIFIED side effects with context.
Group by type. Show trigger conditions.
-->

### Database Operations

| Operation | Location | Trigger | Notes |
|-----------|----------|---------|-------|
| {DB_OP_1} | {DB_LOC_1} | {DB_TRIGGER_1} | {DB_NOTES_1} |

### External API Calls

| Service | Location | Trigger | Notes |
|---------|----------|---------|-------|
| {API_OP_1} | {API_LOC_1} | {API_TRIGGER_1} | {API_NOTES_1} |

### File System

| Operation | Location | Trigger | Notes |
|-----------|----------|---------|-------|
| {FILE_OP_1} | {FILE_LOC_1} | {FILE_TRIGGER_1} | {FILE_NOTES_1} |

<!--
Example:
### Database Operations
| Operation | Location | Trigger | Notes |
|-----------|----------|---------|-------|
| INSERT orders | order_repo.py:34 | Order created | Transaction boundary |
| UPDATE inventory | inventory.py:89 | Item reserved | [VERIFIED] Must rollback on payment failure |

### External API Calls
| Service | Location | Trigger | Notes |
|---------|----------|---------|-------|
| Stripe API | providers/stripe.py:45 | Payment charge | [VERIFIED] Has retry logic, 3 attempts |
| Slack webhook | notifications.py:23 | Order completed | Fire-and-forget, non-critical |
-->

---

## Hazards — Do Not Read

<!--
AGENT INSTRUCTIONS:
Include all hazards from X-Ray.
The next Claude instance must know what to avoid.
-->

| File/Pattern | Size | Why Skip |
|--------------|------|----------|
| {HAZARD_1} | {SIZE_1} | {REASON_1} |

**Glob patterns for exclusion:**
```
{HAZARD_PATTERNS}
```

<!--
Example:
| File/Pattern | Size | Why Skip |
|--------------|------|----------|
| `generated_client.py` | ~45K tokens | Auto-generated API client |
| `migrations/*.py` | ~30K tokens | Schema history, not logic |
| `tests/fixtures/*.json` | ~20K tokens | Test data |

**Glob patterns for exclusion:**
```
**/generated_*.py
**/migrations/*.py
**/fixtures/**
**/*.min.js
```
-->

---

## Gotchas — Things That Will Trip You Up

<!--
AGENT INSTRUCTIONS:
THIS SECTION IS MANDATORY. Document counterintuitive behaviors discovered during investigation.
These are the insights that make your document valuable beyond raw X-Ray output.
Mark each with confidence level.
-->

{GOTCHAS}

<!--
Example:
1. **[VERIFIED] Config must be loaded first** — `get_config()` initializes the logging singleton;
   calling `get_logger()` before `get_config()` causes silent failures with no error message.

2. **[VERIFIED] API key "999..." enables CLI mode** — Setting ANTHROPIC_API_KEY to all 9s
   activates development mode without API costs. Not documented anywhere.

3. **[INFERRED] Import order in __init__.py matters** — Models must import before services
   due to SQLAlchemy mapper configuration. Reordering causes cryptic "mapper not found" errors.

4. **[VERIFIED] Circular import is intentional** — `llm.py <-> anthropic.py` looks like a bug
   but is the provider factory pattern. Don't "fix" it.

5. **[VERIFIED] Race condition in inventory check** — Line 178 does check-then-reserve without
   locking; two concurrent orders can both pass the availability check.
-->

---

## When Things Break (Debugging Guide)

<!--
AGENT INSTRUCTIONS:
Document common failure modes and how to debug them.
This helps the next Claude troubleshoot efficiently.
-->

| Symptom | Check First | Common Cause |
|---------|-------------|--------------|
| {SYMPTOM_1} | {CHECK_1} | {CAUSE_1} |

<!--
Example:
| Symptom | Check First | Common Cause |
|---------|-------------|--------------|
| "LLM call hangs" | `ANTHROPIC_API_KEY` env var | Key invalid or rate limited |
| "Experiment fails silently" | `docker ps` | Sandbox container not running |
| "Import error on startup" | `pip install -e .` | Package not in dev mode |
| "Config not found" | Working directory | Must run from project root |
| "Database connection refused" | `NEO4J_PASSWORD` | Knowledge graph not configured |
-->

---

## Environment & Configuration

### Required Environment Variables

| Variable | Required | Default | Purpose |
|----------|----------|---------|---------|
| {ENV_1} | {REQ_1} | {DEF_1} | {PURPOSE_1} |

### Configuration Files

| File | Purpose |
|------|---------|
| {CONFIG_1} | {CONFIG_PURPOSE_1} |

<!--
Example:
### Required Environment Variables
| Variable | Required | Default | Purpose |
|----------|----------|---------|---------|
| `DATABASE_URL` | **Yes** | — | PostgreSQL connection string |
| `STRIPE_API_KEY` | **Yes** | — | Payment processing |
| `LOG_LEVEL` | No | INFO | Logging verbosity |

### Configuration Files
| File | Purpose |
|------|---------|
| `config/settings.py` | Application settings, loads from env |
| `.env` | Local development overrides (not committed) |
-->

---

## Testing Patterns

<!--
AGENT INSTRUCTIONS:
Include testing conventions so the next Claude writes consistent tests.
-->

**Test location:** `{TEST_DIR}`
**Framework:** {TEST_FRAMEWORK}
**Run command:** `{TEST_COMMAND}`

### Patterns Used

{TEST_PATTERNS}

### Example Test

```python
{TEST_EXAMPLE}
```

<!--
Example:
**Test location:** `tests/`
**Framework:** pytest with pytest-asyncio
**Run command:** `pytest tests/ -v`

### Patterns Used
- Fixtures in `conftest.py` for DB and mocks
- `@pytest.mark.unit` / `@pytest.mark.integration` markers
- `unittest.mock.patch` for external services
- Factory functions for test data (`tests/factories.py`)

### Example Test
```python
@pytest.fixture
def mock_payment_provider():
    return Mock(spec=PaymentProvider)

@pytest.mark.unit
def test_process_order_success(mock_payment_provider, sample_order):
    mock_payment_provider.charge.return_value = PaymentResult(success=True)

    engine = OrderEngine(payment_provider=mock_payment_provider)
    result = engine.process_order(sample_order)

    assert result.success
    mock_payment_provider.charge.assert_called_once()
```
-->

---

## Entry Points for Common Tasks

<!--
AGENT INSTRUCTIONS:
Guide the next Claude on where to start for common tasks.
-->

| Task | Start Here | Key Files |
|------|------------|-----------|
| {TASK_1} | {START_1} | {FILES_1} |

<!--
Example:
| Task | Start Here | Key Files |
|------|------------|-----------|
| Add new API endpoint | `api/routes/` | schemas/, services/ |
| Add payment provider | `providers/base.py` | Implement `PaymentProvider` interface |
| Fix order logic | `core/engine.py` | validators/, services/ |
| Debug data issue | `models/` | Check migrations for schema |
| Add background job | `workers/` | tasks.py, celery_config.py |
-->

---

## What X-Ray Missed (Your Insights)

<!--
AGENT INSTRUCTIONS:
THIS SECTION IS MANDATORY. Add insights you discovered during investigation
that weren't in X-Ray output. This is YOUR value-add as an analyst.
Mark each with confidence level.
-->

{INSIGHTS}

<!--
Example:
1. **[VERIFIED] Feature flags:** Payment providers can be disabled via `ENABLED_PROVIDERS` env var.
   X-Ray saw the config but not the conditional activation in `providers/__init__.py:23`.

2. **[VERIFIED] Rate limiting:** External API calls have a custom rate limiter in `lib/rate_limit.py`.
   Not detected as a pattern by X-Ray.

3. **[VERIFIED] Potential race condition:** `inventory.py:78` checks availability then reserves in
   separate queries. Two concurrent orders could both pass the check. Suggest using
   `SELECT FOR UPDATE`.

4. **[INFERRED] Implicit dependency:** `OrderService` assumes `InventoryService` is initialized first.
   No explicit dependency injection — relies on import order in `services/__init__.py`.

5. **[VERIFIED] Prompt caching enabled:** Claude calls use prompt caching by default (`enable_cache: true`).
   Reduces API costs by ~90% for repetitive operations.
-->

---

## What This Document Doesn't Cover (Gaps)

<!--
AGENT INSTRUCTIONS:
Be honest about limitations. This helps the next Claude know where to dig deeper.
-->

{GAPS}

<!--
Example:
- **Knowledge graph internals** — Neo4j integration is optional; didn't investigate deeply
- **Schema migrations** — Alembic setup exists but migration strategy unclear
- **Performance tuning** — No profiling data; unknown bottlenecks
- **Multi-tenancy** — Not clear if supported; would need investigation
-->

---

## Recommended Reading Order

<!--
AGENT INSTRUCTIONS:
If the next Claude needs to read more code, this is the priority order.
Based on YOUR investigation, not just X-Ray ranking.
-->

**For understanding the system:**
1. `{READ_1}` — {READ_1_WHY}
2. `{READ_2}` — {READ_2_WHY}
3. `{READ_3}` — {READ_3_WHY}

**Skip these:**
- `{SKIP_1}` — {SKIP_1_WHY}

<!--
Example:
**For understanding the system:**
1. `core/engine.py` — Central orchestrator, start here
2. `models/order.py` — Core data model, understand the domain
3. `providers/base.py` — Payment provider interface
4. `api/routes/orders.py` — See how requests enter the system

**Skip these:**
- `lib/utils.py` — Just string helpers, not architectural
- `migrations/` — Schema history, not needed for coding
- `tests/fixtures/` — Test data, read actual tests instead
-->

---

## Quick Reference

### Key Commands

```bash
# Run the app
{RUN_COMMAND}

# Run tests
{TEST_COMMAND}

# Lint/format
{LINT_COMMAND}
```

### Key Imports

```python
# Core components
{KEY_IMPORTS}
```

### Linter Rules

{LINTER_RULES}

<!--
Example:
### Key Commands
```bash
# Run the app
uvicorn main:app --reload

# Run tests
pytest tests/ -v

# Lint/format
ruff check . && black .
```

### Key Imports
```python
# Core components
from core.engine import OrderEngine
from models import Order, OrderItem, User
from services import OrderService, InventoryService
from providers import get_payment_provider
```

### Linter Rules
```toml
[tool.ruff]
line-length = 100
select = ["E", "W", "F", "I", "B"]
ignore = ["E501", "B008", "C901"]
```
Translation: Max 100 chars (but E501 ignored), imports sorted (I), no bare excepts (B).
-->

---

## Quality Metrics

<!--
AGENT INSTRUCTIONS:
Report these metrics at the end of your document.
They help users understand the depth of analysis.
-->

| Metric | Value |
|--------|-------|
| Pillars investigated | {PILLARS_INVESTIGATED} |
| Hotspots with verdicts | {HOTSPOTS_VERDICTS} |
| [VERIFIED] insights | {VERIFIED_COUNT} |
| [INFERRED] insights | {INFERRED_COUNT} |
| Gotchas documented | {GOTCHAS_COUNT} |
| Error paths documented | {ERROR_PATHS_COUNT} |
| Compression ratio | {COMPRESSION_RATIO} |

---

*This onboarding document was prepared by the repo_xray agent using the four-phase workflow:
ORIENT (read X-Ray scan) → INVESTIGATE (verify signals, two passes) → SYNTHESIZE (curate with judgment) → VALIDATE (self-test).*

*It compresses a {TOTAL_TOKENS}-token codebase into ~{DOC_TOKENS} tokens of actionable intelligence optimized for AI coding assistants.*

*For deeper exploration, use the `@repo_xray query` or `@repo_xray focus` modes.*
